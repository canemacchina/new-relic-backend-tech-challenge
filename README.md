# New Relic backend tech challenge

## REQUIREMENTS

- java (jdk 17)

## Run

### Run directly from maven:

```shell
    $ ./mvnw clean package exec:java
```

Add `-DskipTests` to skip executing tests. (`$ ./mvnw clean package exec:java -DskipTests`)

Export `MAVEN_OPTS` to set application max memory,
eg `$ MAVEN_OPTS="-Xmx1g" ./mvnw clean package exec:java -DskipTests`

### Compile and run

```shell
    $ ./mvnw clean package
    $ java -jar build/new-relic-backend-tech-challenge-1.0-shaded.jar 
```

Add `-DskipTests` to skip executing tests. (`$ ./mvnw clean package -DskipTests`)

Add memory option after java command,
eg `$ java -Xmx1g -jar build/new-relic-backend-tech-challenge-1.0-shaded.jar`

## TESTING

Apart fom unit tests, into the `load_test` folder there are two simple script to run some load
test.

`generateData.sh` can be used to generate some files with some 9 digits numbers. By default, every
file will contain 10^7 random numbers, and will be named `dataX`, where `X` is a 1-based index
based on how many file were generated

`test.sh` can be used to spawn some clients and start sending numbers to the application (it needs
`netcat` to be installed in the system). Clients are run in separate processes, so they will be all
parallel. by default, the i-th client will read from i-th data file (generated by the previous
script)

## DESIGN

### Architecture design

To leave the structure simple, two packages have been created.

- `it.lorenzobugiani.application` contains classes related to the "application" as it was defined in
  the assignment.
- `it.lorenzobugiani.client` contains classes related to client handling.

Then, the `Main` class glue everything starting both application thread and client listener.

### Motivation behind choices

#### Programming languages

Considering that application performance was one of the things to take into account, from the
list of available programming languages maybe Go would have been the best choice, due to its
compiled nature. But considering my very basic knowledge of that language, I preferred to go with
the one I know better, therefore I picked Java.

Anyway, probably any of those languages would have been fine because the application is heavily I/O
bounded (the most expensive operation is probably writing to the disk) so I think that the language
wouldn't have mattered too much.

### Implementation

Implementation choices were made considering primarily performance and robustness:

- minimize thread synchronization with the help of batch operations and buffers;
- writing to disk using buffering, using a BufferedWriter that is usually more efficient when every
  write is small and when multiple writes occur between flushes;
- optimize space and time for checking for duplicates, using a BitSet to maintain that information.
  BitSet allow for check for duplicate in O(1) using linear space in bit (so at most ~120MB of
  memory for the whole 9 digits number space);
- finding a good sweet spot between memory usage and performance: bigger queue for
  client/application communication can improve performance (in terms of backpressure applied), at
  the cost of more memory used (see below performance section);
- flushing client handler buffer also on socket inactivity, to avoid data loss on application
  termination for buffers not yet copied to the application queue due to client inactivity;
- flushing data from log writer buffer to disk periodically in a separate thread, to be sure that
  data are written to the disk but without blocking the main thread on I/O operations.

## Performance

Using scripts in the `load_test` folder is possible to have a rough idea of how many numbers per sec
the application can handle.

The application was tested on a Dell laptop with:

- Linux
- Intel i7 11gen processor (2.3GHz to 4.6GHz max turbo frequency)
- 1GB of ram for the jvm process.

Tests were executed spawning 5 clients each of which was sending 10^7 numbers, before disconnect.
Various tests were made based on different dimensions for the client/application queue.
Throughput was calculated as the average number of read numbers (from the socket) every 10s.

| Queue dimension | Occupied space | Avg time | Worst time | Throughput |
|-----------------|----------------|----------|------------|------------|
| 8 * 1024        | 32MB           | 4.79s    | 5.21s      | 96,0M      |
| 16 * 1024       | 64MB           | 4.19s    | 4.27s      | 117.1M     |
| 32 * 1024       | 128MB          | 2.11s    | 2.20s      | 227.3M     |
| 64 * 1024       | 256MB          | 0.66s    | 0.72s      | 694.4M     |
| 128 * 1024      | 512MB          | 0.64s    | 0.67       | 746.3M     |
